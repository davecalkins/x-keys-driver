<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>TinyXml: TinyXML++</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="index.html">index</a>&nbsp;&raquo&nbsp;<a class="el" href="ticppTutorial.html">TinyXML++ Tutorial</a>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="ticpp">TinyXML++ </a></h1><h2>General Concepts </h2>
<p>
The TinyXML++ classes are all wrappers around the corresponding classes within TinyXML.<p>
There is no reason to create TinyXML++ objects on the heap, using <code>new</code>, because the memory is managed for you. If you choose to use <code>new</code> to create TinyXML++ objects, you will <b>always</b> need to use <code>delete</code> to clean up.<p>
Basically, TinyXML++ objects are just wrappers around TinyXML pointers.<p>
<h2>Goals </h2>
<p>
<ul>
<li>Simplify the use and interface of TinyXml, using C++ concepts.<ul>
<li>Use exceptions for error handling, so there are no return codes to check</li><li>Use templates for automatic type conversion</li><li>Use STL style iterators to move through nodes and attributes</li></ul>
</li></ul>
<p>
<h2>Details </h2>
<p>
<h3>Use exceptions for error handling </h3>
<p>
When using the original TinyXML, every function returns a value indicating success or failure. A programmer would have to check that value to ensure the function succeeded.<p>
Example: <div class="fragment"><pre class="fragment"> Load a document
<a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a> doc( pFilename );
<span class="keywordflow">if</span> ( !doc.LoadFile() ) <span class="keywordflow">return</span>;

 Get a node
<a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* pElem = doc.FirstChildElement();
<span class="keywordflow">if</span> ( !pElem ) <span class="keywordflow">return</span>;

 Get the node we want
pElem = pElem-&gt;NextSibling();
<span class="keywordflow">if</span> ( !pElem ) <span class="keywordflow">return</span>;

 <span class="keywordflow">do</span> something useful here
</pre></div><p>
An alternative was to use <a class="el" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a>, which allows for function chaining by checking the intermediate function return values:<p>
Example: <div class="fragment"><pre class="fragment"> Load a document
<a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a> doc(pFilename);
<span class="keywordflow">if</span> (!doc.LoadFile()) <span class="keywordflow">return</span>;

 Make a document handle
<a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> hDoc(&amp;doc);

 Get an element by <span class="keyword">using</span> the handle to chain calls
 Note the conversion of the <a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> to the <a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* - .Element()
<a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* pElem = hDoc.FirstChildElement().NextSibling().Element();
<span class="keywordflow">if</span> ( !pElem ) <span class="keywordflow">return</span>;

 <span class="keywordflow">do</span> something useful here
</pre></div><p>
With TinyXML++, if there is an error during a function call, it throws an exception. This means that a programmer can assume that every function is successful, as long as the functions are enclosed in a try-catch block.<p>
Example: <div class="fragment"><pre class="fragment"><span class="keywordflow">try</span>
{
 Load a document
    <a class="code" href="classticpp_1_1Document.html" title="Wrapper around TiXmlDocument.">ticpp::Document</a> doc( pFilename );
    doc.LoadFile();

 Get an element by chaining calls - no <span class="keywordflow">return</span> values to check, no <a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a>
    <a class="code" href="classticpp_1_1Element.html" title="Wrapper around TiXmlElement.">ticpp::Element</a>* pElem = doc.<a class="code" href="classTiXmlNode.html#f4fb652f6bd79ae0d5ce7d0f7d3c0fba" title="Convenience function to get through elements.">FirstChildElement</a>()-&gt;<a class="code" href="classTiXmlNode.html#1b94d2f7fa7ab25a5a8e8d4340c449c9" title="STL std::string form.">NextSibling</a>();

 <span class="keywordflow">do</span> something useful here
}
<span class="keywordflow">catch</span>( <a class="code" href="classticpp_1_1Exception.html" title="This is a ticpp exception class.">ticpp::Exception</a>&amp; ex )
{
 If any function has an error, execution will enter here.
 Report the error
    std::cout &lt;&lt; ex.<a class="code" href="classticpp_1_1Exception.html#eac1f13b96eb4e1f2a3659dc9080edd6" title="Override std::exception::what() to return m_details.">what</a>();
}
</pre></div><p>
<h3>Use templates for automatic type conversion </h3>
<p>
When using TinyXML, a programmer either needs to convert values to and from strings, or choose from one of many overloads to get the value in the desired type.<p>
Example: <div class="fragment"><pre class="fragment"> Load a document
<a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a> doc( pFilename );
<span class="keywordflow">if</span> ( !doc.LoadFile() ) <span class="keywordflow">return</span>;

 Get a node
<a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* pElem = doc.FirstChildElement();
<span class="keywordflow">if</span> ( !pElem ) <span class="keywordflow">return</span>;

 Get the node we want
pElem = pElem-&gt;NextSibling();
<span class="keywordflow">if</span> ( !pElem ) <span class="keywordflow">return</span>;

 Get the attribute as a string, convert to <span class="keywordtype">int</span>
<span class="keyword">const</span> <span class="keywordtype">char</span>* pszAttr = pElem-&gt;Attribute( <span class="stringliteral">"myAttribute"</span> );
<span class="keywordtype">int</span> attr = atoi( pszAttr );

 Get the attribute as an <span class="keywordtype">int</span>
<span class="keywordtype">int</span> attr2;
<span class="keywordflow">if</span> ( TIXML_SUCCESS != pElem-&gt;QueryIntAttribute( <span class="stringliteral">"myAttribute"</span>, &amp;attr2 ) )
{
    <span class="keywordflow">return</span>;
}

 Get the attribute as a <span class="keywordtype">double</span>
<span class="keywordtype">double</span> attr3;
<span class="keywordflow">if</span> ( TIXML_SUCCESS != pElem-&gt;QueryDoubleAttribute( <span class="stringliteral">"myAttribute"</span>, &amp;attr3 ) )
{
    <span class="keywordflow">return</span>;
}

 Get the attribute as a <span class="keywordtype">float</span>
<span class="keywordtype">float</span> attr4;
<span class="keywordflow">if</span> ( TIXML_SUCCESS != pElem-&gt;QueryFloatAttribute( <span class="stringliteral">"myAttribute"</span>, &amp;attr4 ) )
{
    <span class="keywordflow">return</span>;
}
</pre></div><p>
TinyXML++ uses templates for automatic type conversion.<p>
Example: <div class="fragment"><pre class="fragment"><span class="keywordflow">try</span>
{
 Load a document
    <a class="code" href="classticpp_1_1Document.html" title="Wrapper around TiXmlDocument.">ticpp::Document</a> doc( pFilename );
    doc.LoadFile();

 Get an element by chaining calls - no <span class="keywordflow">return</span> values to check, no <a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a>
    <a class="code" href="classticpp_1_1Element.html" title="Wrapper around TiXmlElement.">ticpp::Element</a>* pElem = doc.FirstChildElement()-&gt;NextSibling();

 GetAttribute can determine the type of the pointer, and convert automatically

 Get the attribute as a <span class="keywordtype">string</span>
    std::string attr;
    pElem-&gt;GetAttribute( <span class="stringliteral">"myAttribute"</span>, &amp;attr );

 Get the attribute as an <span class="keywordtype">int</span>
    <span class="keywordtype">int</span> attr2;
    pElem-&gt;GetAttribute( <span class="stringliteral">"myAttribute"</span>, &amp;attr2 );

 Get the attribute as an <span class="keywordtype">float</span>
    <span class="keywordtype">float</span> attr3;
    pElem-&gt;GetAttribute( <span class="stringliteral">"myAttribute"</span>, &amp;attr3 );

 Get the attribute as an <span class="keywordtype">double</span>
    <span class="keywordtype">double</span> attr4;
    pElem-&gt;GetAttribute( <span class="stringliteral">"myAttribute"</span>, &amp;attr4 );

 Get the attribute as an <span class="keywordtype">bool</span>
    <span class="keywordtype">bool</span> attr5;
    pElem-&gt;GetAttribute( <span class="stringliteral">"myAttribute"</span>, &amp;attr5 );

}
<span class="keywordflow">catch</span>( <a class="code" href="classticpp_1_1Exception.html" title="This is a ticpp exception class.">ticpp::Exception</a>&amp; ex )
{
 If any function has an error, execution will enter here.
 Report the error
    std::cout &lt;&lt; ex.<a class="code" href="classticpp_1_1Exception.html#eac1f13b96eb4e1f2a3659dc9080edd6" title="Override std::exception::what() to return m_details.">what</a>();
}
</pre></div> <h3>Use STL style iterators to move through nodes and attributes </h3>
<p>
TinyXML has two ways to iterate:<p>
First Method: <div class="fragment"><pre class="fragment">    <span class="keywordflow">for</span>( child = parent-&gt;FirstChild( <span class="keyword">false</span> ); child; child = child-&gt;NextSibling( <span class="keyword">false</span> ) )
</pre></div><p>
Second Method: <div class="fragment"><pre class="fragment">    child = 0;
    <span class="keywordflow">while</span>( child = parent-&gt;IterateChildren( child ) )
</pre></div><p>
Although both methods work quite well, the syntax is not familiar. TinyXML++ introduces iterators: <div class="fragment"><pre class="fragment"><a class="code" href="classticpp_1_1Iterator.html" title="Iterator for conveniently stepping through Nodes and Attributes.">ticpp::Iterator&lt; ticpp::Node &gt;</a> child;
<span class="keywordflow">for</span> ( child = child.<a class="code" href="classticpp_1_1Iterator.html#056e73d1bed641f43114b9d4e9f0f29e" title="For for loop comparisons.">begin</a>( parent ); child != child.<a class="code" href="classticpp_1_1Iterator.html#7b4a49c16cff8c8470cc5c9a63810cd5" title="For for loop comparisons.">end</a>(); child++ )
</pre></div><p>
Iterators have the added advantage of filtering by type: <div class="fragment"><pre class="fragment"> Only iterates through Comment nodes
<a class="code" href="classticpp_1_1Iterator.html" title="Iterator for conveniently stepping through Nodes and Attributes.">ticpp::Iterator&lt; ticpp::Comment &gt;</a> child;
<span class="keywordflow">for</span> ( child = child.begin( parent ); child != child.end(); child++ )
</pre></div><p>
<div class="fragment"><pre class="fragment"> Only iterates through Element nodes with value <span class="stringliteral">"ElementValue"</span>
<a class="code" href="classticpp_1_1Iterator.html" title="Iterator for conveniently stepping through Nodes and Attributes.">ticpp::Iterator&lt; ticpp::Element &gt;</a> child( <span class="stringliteral">"ElementValue"</span> );
<span class="keywordflow">for</span> ( child = child.begin( parent ); child != child.end(); child++ )
</pre></div><p>
Finally, Iterators also work with Attributes <div class="fragment"><pre class="fragment"><a class="code" href="classticpp_1_1Iterator.html" title="Iterator for conveniently stepping through Nodes and Attributes.">ticpp::Iterator&lt; ticpp::Attribute &gt;</a> attribute;
<span class="keywordflow">for</span> ( attribute = attribute.<a class="code" href="classticpp_1_1Iterator.html#056e73d1bed641f43114b9d4e9f0f29e" title="For for loop comparisons.">begin</a>( element ); attribute != attribute.<a class="code" href="classticpp_1_1Iterator.html#7b4a49c16cff8c8470cc5c9a63810cd5" title="For for loop comparisons.">end</a>(); attribute++ )
</pre></div> </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sun Feb 15 23:12:13 2009 for TinyXml by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
